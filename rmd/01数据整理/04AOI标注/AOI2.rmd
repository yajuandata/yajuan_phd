---
title: "AOI"
output: html_document
date: "2023-08-17"
---
摘要：标注saccade数据的AOI，改变打标方式，增加BG区域的判断方法

加载包
```{r} 
library(tidyverse)
library(readxl)
library(furrr)
library(data.table)
```

定义计算方法
```{r}
calculate_saccade_angle <- function(input_file_path, output_file_path) {
  # 读取 AOI 坐标信息，将坐标部分数据转换为数字格式
  aoi <- readxl::read_excel("info/area2.xlsx") %>%
    mutate_at(vars(3:6), as.numeric)

  # 读取输入文件，并添加行号
  dt <- fread(input_file_path) %>%
    mutate(RowNumber = row_number())

  # 将 dt 和 aoi 进行左连接，并添加 AOI_S 和 AOI_E 列
  result <- dt %>%
    left_join(aoi, by = "pic", relationship = "many-to-many") %>%
    mutate(
      AOI_S = ifelse(
        sxp >= X1 & syp >= Y1 & sxp <= X2 & syp <= Y3,
        area, NA
      ),
      AOI_E = ifelse(
        exp >= X1 & eyp >= Y1 & exp <= X2 & eyp <= Y3,
        area, NA
      )
    )

  # 从 result 中选择部分列，并去除重复行，得到 r1
  r1 <- result %>%
    select(-AOI_E, -area, -X1, -X2, -Y1, -Y3) %>%
    unique()

  # 从 result 中选择部分列，并去除重复行，得到 r2
  r2 <- result %>%
    select(-AOI_S, -area, -X1, -X2, -Y1, -Y3) %>%
    unique()

  # 使用dplyr对r1进行分组并汇总，得到dt_r1
  dt_r1 <- r1 %>%
    group_by(block, pic, RowNumber) %>%
    summarize(AOI_S = ifelse(all(is.na(AOI_S)), NA, first(na.omit(AOI_S))))

  # 使用dplyr对r2进行分组并汇总，得到dt_r2
  dt_r2 <- r2 %>%
    group_by(block, pic, RowNumber) %>%
    summarize(AOI_E = ifelse(all(is.na(AOI_E)), NA, first(na.omit(AOI_E))))

  # 将dt_r1和dt_r2进行全连接，然后与dt进行左连接，并添加AOI_S和AOI_E列，得到new_dt
  new_dt <- full_join(dt_r1, dt_r2) %>%
    left_join(dt) %>%
    mutate(
      AOI_S = if_else(is.na(AOI_S) & (between(sxp, 0, 1280) & between(syp, 0, 1024)), "BG", AOI_S),
      AOI_E = if_else(is.na(AOI_E) & (between(exp, 0, 1280) & between(eyp, 0, 1024)), "BG", AOI_E)
    )

  # 将new_dt保存到输出文件路径中
  fwrite(new_dt, output_file_path, na = "NA")
}

# 定义函数batch_calculate_saccade_angle，该函数对指定目录下的全部文件进行批量处理，
# 并将处理结果输出到指定的目录下。该函数接收三个参数：输入文件的目录、输出文件的目录和工作线程的数量。
batch_calculate_saccade_angle <- function(input_dir, output_dir, wk = 5) {
  # 获取输入目录下的全部文件的路径
  input_file_paths <- list.files(input_dir, full.names = TRUE)

  # 生成输出文件的路径
  output_file_paths <- str_replace(input_file_paths, input_dir, output_dir)

  # 设置并行计划，使用多个会话进行并行计算
  plan(multisession, workers = wk)

  # 对输入目录下的全部文件进行批量处理，并将处理结果输出到指定的目录下
  future_map2(input_file_paths, output_file_paths, calculate_saccade_angle)

  # 重置并行计划为顺序计划
  plan(sequential)
}
```

调用方法，批量计算
```{r}
# 输入目录
input_dir <- "../yajuan_data/out/sacc2"
# 输出目录
output_dir <- "../yajuan_data/out/sacc2_AOI"
# 建立输出目录
dir.create(output_dir, recursive = TRUE)
# 调用方法
batch_calculate_saccade_angle(input_dir, output_dir)
```
